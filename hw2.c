#pragma config(Sensor, S1,     leftLight,      sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S2,     ultraSonic,     sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     rightLight,     sensorEV3_Color, modeEV3Color_Color)
#pragma config(Motor,  motorA,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorD,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int speed = 60;
int fullSpeed = 0;
int stoppeds = 0;

void moveForward(int left, int right) {
	setMotorSpeed(leftMotor, left);
	setMotorSpeed(rightMotor, right);
}


//this is for wondering right
void randomRight() {
	setMotorSpeed(leftMotor, 45);
	setMotorSpeed(rightMotor, 35);
}

//this is for wondering left
void randomLeft() {
	setMotorSpeed(leftMotor, 35);
	setMotorSpeed(rightMotor, 45);
}

//this is the random walking task.
task randomWalk() {
	//varibles that
	long rTime = 0;
	long turnProb = 0;
	long rightProbability = 50;
	long leftProbability = 50;


//this loop will let robot walking repeatly but with random pattern.
  while(true) {
  	//generates number between 0 and 99.
  	//starts with 50/50 chance of going left or right.
  	//lower end of probability will always be for turning left.
  	turnProb = rand() % 100;
  	rTime = rand() % 900 + 300;

	//random turning algorithm.
  	if(turnProb < leftProbability) {
  		randomLeft();
  		rightProbability += 10;
  		leftProbability -= 10;
  	} else {
  		randomRight();
  		rightProbability -= 10;
  		leftProbability += 10;
  	}
		wait1Msec(rTime);
	}
}

void shiftElements(int *data) {
		int i;
		for(i = 0; i < 4; i++) {
			data[i] = data[i+1];	
		}
}

float calculateAvg(int *data, int count) {
	int i;
	int avg = 0;
	for(i = 0; i < count; i++) {
		avg += data[i];
	}
	avg /= count;
	return avg;
}


task detect() {
	int count = 0;
	int data[5];
	float avg = 0;
		
	while(true) {
		/*if (getColorName(S4) == colorBlack) {
		playTone(784, 15);
		delay(1000);
		} */
		
		//displayBigTextLine(3, "%d", distance);
		//displayBigTextLine(5, "%d", speed);

		
		int distance = getUSDistance(ultraSonic);
		if(count < 5) {
			data[count] = distance;
			count++;
		} else {
			shiftElements(data);
			data[4] = distance;
		}
		
		avg = calculateAvg(data, count);
		
			displayBigTextLine(3, "%f", avg);
		  displayBigTextLine(5, "%d", distance);
		

		//check if the obstacle is in the range of detection
		if(avg < 90) {
			stopTask(randomWalk);
			if(avg > 70) {
				speed = 80;
				moveForward(speed, speed);
				wait1Msec(800);
			}else if(avg > 50){
				speed = 75;
				moveForward(speed, speed);
				wait1Msec(800);
			}else if(avg > 30) {
				speed = 60;
				moveForward(speed, speed);
				wait1Msec(800);
			}else if (avg > 20) {
				speed = 55;
				moveForward(speed, speed);
				wait1Msec(800);
			}else if (avg > 13) {
				speed = 30;
				moveForward(speed, speed);
				wait1Msec(400);
			} else if (avg > 7) {
				speed = 15;
				moveForward(speed, speed);
				wait1Msec(300);
			}else if (avg > 3) {
				speed = 5;
				moveForward(speed, speed);
				wait1Msec(100);
			}else {
				moveForward(0, 0);
				wait1Msec(4000);
				startTask(randomWalk);
			}
			//wait1Msec(400);
			}else{

		}
	}
}

task main()
{
	startTask(detect);
	startTask(randomWalk);
	while(true) {

	}
}
