#pragma config(Sensor, S1,     leftLight,      sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S2,     ultraSonic,     sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     rightLight,     sensorEV3_Color, modeEV3Color_Color)
#pragma config(Motor,  motorA,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorD,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int speed = 60;

//move the robot forward
void moveForward(int left, int right) {
	setMotorSpeed(leftMotor, left);
	setMotorSpeed(rightMotor, right);
}

//move the robot backward
void moveBackwards(int left, int right) {
	setMotorSpeed(leftMotor, left);
	setMotorSpeed(rightMotor, right);
}

//robot turns on the right side
void turnRight() {
	setMotorSpeed(leftMotor, 40);
	setMotorSpeed(rightMotor, -40);
}

//robot turns on the left side
void turnLeft() {
	setMotorSpeed(leftMotor, -40);
	setMotorSpeed(rightMotor, 40);
}

//this is for wondering right
void randomRight() {
	setMotorSpeed(leftMotor, 45);
	setMotorSpeed(rightMotor, 35);
}

//this is for wondering left
void randomLeft() {
	setMotorSpeed(leftMotor, 35);
	setMotorSpeed(rightMotor, 45);
}

/*
the robot will turn in random direction when it is close to the obstacle within 1 inch
*/
void turnRandomly() {
	if(rand() % 100 < 50) {
		turnLeft();
		wait1Msec(600);
		} else {
		turnRight();
		wait1Msec(600);
	}
}




//this is the random walking task.
task randomWalk() {
	//varibles that
	long rTime = 0;
	long turnProb = 0;
	long rightProbability = 50;
	long leftProbability = 50;


	//this loop will let robot walking repeatly but with random pattern.
	while(true) {
		//generates number between 0 and 99.
		//starts with 50/50 chance of going left or right.
		//lower end of probability will always be for turning left.
		turnProb = rand() % 100;
		rTime = rand() % 900 + 300;

		//random turning algorithm.
		if(turnProb < leftProbability) {
			randomLeft();
			rightProbability += 10;
			leftProbability -= 10;
			} else {
			randomRight();
			rightProbability -= 10;
			leftProbability += 10;
		}
		wait1Msec(rTime);
	}
}


/*
this is the task when the robot detects the black lines using the light sensors
*/
task lineFollow() {
	//the variable store value relected from the left and right light sensor
	int leftReflected, rightReflected;
	//the flag to check whether the random walk task is started
	int started = 0;
	//the flag to check whether the robot find the line while doing the end of line detection
	int foundLine = 0;
	//the flag to check whether both light sensor detect black color
	int both = 0;

	while(true) {
		foundLine = 0;
		leftReflected = getColorReflected(leftLight);
		rightReflected = getColorReflected(rightLight);
		//stop the random walk if light sensor finds the black line
		if( leftReflected < 4) {
			stopTask(randomWalk);
			started = 1;
			if(rightReflected < 4) {
				/*
				move left slightly when both sensor detect black
				*/
				if(both == 0) {

					setMotorSync(leftMotor, rightMotor, -20, 20);
					wait1Msec(200);
					both = 1;
				}
				//move forward
				moveForward(20, 20);
				wait1Msec(100);
			} else {
				//only the left color sensor noticed black line so turn left.
				setMotorSync(leftMotor, rightMotor, -40, 20);
				wait1Msec(200);
			}
		} else if(rightReflected < 4){
			//only the right color sensor noticed black line so turn right.
			stopTask(randomWalk);
			// move right
			setMotorSync(leftMotor, rightMotor, 40, 20);
			wait1Msec(200);
		}else {

			//start the random walk task if it has been stopped previously
			if(started == 1) {
				//both detect white color
				moveForward(20,20);
				wait1Msec(250);
				setMotorSync(leftMotor, rightMotor, 0, 0);

				int i = 1;
				//turn left
				setMotorSpeed(leftMotor, -20);
				setMotorSpeed(rightMotor, 20);

				//check if the robot detect the black line during the left turn
				while(i <= 4 && foundLine == 0) {
					leftReflected = getColorReflected(leftLight);
					if(leftReflected < 3) {
						foundLine = 1;
						} else {
						wait1Msec(200);
						i += 1;
					}

				}

				//if it didnt find the line when turning left
				//it turns right and check for the black line
				if(foundLine == 0) {
					//turn right
					setMotorSpeed(leftMotor, 20);
					setMotorSpeed(rightMotor, -20);
					i = 0;
					while(i <= 6 && foundLine == 0) {
						rightReflected = getColorReflected(rightLight);
						if(rightReflected < 3) {
							foundLine = 1;
							} else {
							wait1Msec(200);
							i += 1;
						}
					}
				}

				//start the random walk task if both light sensors don't detect black line
				if(!foundLine) {
					startTask(randomWalk);
					started = 0;
					both = 0;
					playTone(800, 5);
				}
			}
		}
	}
}

//this is the task to detect the obstacle
task detect() {
	//the variable stop the average of the distance from 50 times ultrasonic detection
	float avg = 0;
	//total value of the distances
	int total = 0;
	int i;
	//the flag to check whether the random walk task is started
	int start = 0;

	while(true) {
		//calcute the average of the distance
		for(i = 0; i < 50; i++) {
			int distance = getUSDistance(ultraSonic);
			//data[i] = distance;
			total += distance;
		}

		avg = total/ 50;
		//avg = getUSDistance(ultraSonic);

		displayBigTextLine(3, "%f", avg);



		//check if the obstacle is in the range of detection
		if(avg < 100) {
			stopTask(randomWalk);
			stopTask(lineFollow);
			start = 1;
			if(avg > 88) {
				speed = 80;
				moveForward(speed, speed);
				wait1Msec(100);
				}else if(avg > 68){
				speed = 68;
				moveForward(speed, speed);
				wait1Msec(100);
				}else if(avg > 56) {
				speed = 56;
				moveForward(speed, speed);
				wait1Msec(100);
				}else if (avg > 44) {
				speed = 44;
				moveForward(speed, speed);
				wait1Msec(100);
				}else if (avg > 32) {
				speed = 32;
				moveForward(speed, speed);
				wait1Msec(100);
				} else if (avg > 20) {
				speed = 20;
				moveForward(speed, speed);
				wait1Msec(100);
				}else if (avg > 10) {
				speed = 12;
				moveForward(speed, speed);
				wait1Msec(100);
				}else {
				//stop for 4 second
				moveForward(0, 0);
				wait1Msec(4000);
				//backward for 1.5 second
				moveBackwards(-40, -40);
				wait1Msec(1500);
				//randomly turn in any direction
				turnRandomly();
				//continute random walk and line follow
				start = 0;
				startTask(randomWalk);
				startTask(lineFollow);
			}
			}else {
			if(start == 1) {
				startTask(randomWalk);
				startTask(lineFollow);
				start = 0;
			}
		}
		//reset the average and total
		avg = 0;
		total = 0;
	}
}

task main()
{
	startTask(randomWalk);
	startTask(lineFollow);
	startTask(detect);

	while(true) {

	}
}
