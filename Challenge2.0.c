#pragma config(Sensor, S1,     leftLight,      sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S2,     ultraSonic,     sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     rightLight,     sensorEV3_Color, modeEV3Color_Color)
#pragma config(Motor,  motorA,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorD,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int speed = 60;
int fullSpeed = 0;
int stoppeds = 0;

void moveForward(int left, int right) {
	setMotorSpeed(leftMotor, left);
	setMotorSpeed(rightMotor, right);
}

void moveBackwards(int left, int right) {
	setMotorSpeed(leftMotor, left);
	setMotorSpeed(rightMotor, right);
}

//this is for wondering right
void turnRight() {
	setMotorSpeed(leftMotor, 40);
	setMotorSpeed(rightMotor, -40);
}

//this is for wondering left
void turnLeft() {
	setMotorSpeed(leftMotor, -40);
	setMotorSpeed(rightMotor, 40);
}

//this is for wondering right
void randomRight() {
	setMotorSpeed(leftMotor, 45);
	setMotorSpeed(rightMotor, 35);
}

//this is for wondering left
void randomLeft() {
	setMotorSpeed(leftMotor, 35);
	setMotorSpeed(rightMotor, 45);
}

void turnRandomly() {
	if(rand() % 100 < 50) {
		turnLeft();
		wait1Msec(600);
		} else {
		turnRight();
		wait1Msec(600);
	}
}




//this is the random walking task.
task randomWalk() {
	//varibles that
	long rTime = 0;
	long turnProb = 0;
	long rightProbability = 50;
	long leftProbability = 50;


	//this loop will let robot walking repeatly but with random pattern.
	while(true) {
		//generates number between 0 and 99.
		//starts with 50/50 chance of going left or right.
		//lower end of probability will always be for turning left.
		turnProb = rand() % 100;
		rTime = rand() % 900 + 300;

		//random turning algorithm.
		if(turnProb < leftProbability) {
			randomLeft();
			rightProbability += 10;
			leftProbability -= 10;
			} else {
			randomRight();
			rightProbability -= 10;
			leftProbability += 10;
		}
		wait1Msec(rTime);
	}
}


void lookLeft() {
	//move left
	setMotorSync(leftMotor, rightMotor, -40, 20);
	wait1Msec(800);
}

void lookRight() {
	//move left
	setMotorSync(leftMotor, rightMotor, 40, 20);
	wait1Msec(1600);
}


task lineFollow() {
	int leftReflected, rightReflected;
	int start = 0;
	int foundLine = 0;

	while(true) {
		foundLine = 0;
		leftReflected = getColorReflected(leftLight);
		rightReflected = getColorReflected(rightLight);
		if( leftReflected < 4) {
			stopTask(randomWalk);
			start = 1;
			if(rightReflected < 4) {
				//move forward
				moveForward(20, 20);
				wait1Msec(100);
				} else {
				//move left
				setMotorSync(leftMotor, rightMotor, -40, 20);
				wait1Msec(200);
			}
			} else if(rightReflected < 4){
			stopTask(randomWalk);
			// move right
			setMotorSync(leftMotor, rightMotor, 40, 20);
			wait1Msec(200);
			}else {
			if(start) {
				//both detect white color
				setMotorSync(leftMotor, rightMotor, 0, 0);
				//wait1Msec()
				//look left

				int i = 1;
				setMotorSpeed(leftMotor, -20);
				setMotorSpeed(rightMotor, 20);


				while(i <= 4 && foundLine == 0) {
					leftReflected = getColorReflected(leftLight);
					if(leftReflected < 4) {
						foundLine = 1;
						} else {
						wait1Msec(200);
						i += 1;
					}

				}

				//didnt find the line when turning left
				if(foundLine == 0) {
					//look right
					setMotorSpeed(leftMotor, 20);
					setMotorSpeed(rightMotor, -20);
					i = 0;
					while(i <= 6 && foundLine == 0) {
						rightReflected = getColorReflected(rightLight);
						if(rightReflected < 4) {
							foundLine = 1;
							} else {
							wait1Msec(200);
							i += 1;
						}
					}
				}

				if(!foundLine) {
					startTask(randomWalk);
					start = 0;
					playTone(600, 1);
				}
			}

		}


	}
}


task detect() {
	float avg = 0;
	int total = 0;
	int i;
	int start = 0;

	while(true) {

		//for(i = 0; i < 100; i++) {
		//	int distance = getUSDistance(ultraSonic);
		//	//data[i] = distance;
		//	total += distance;
		//}

		//avg = total/ 100;
		avg = getUSDistance(ultraSonic);

		displayBigTextLine(3, "%f", avg);
		//displayBigTextLine(5, "%d", distance);


		//check if the obstacle is in the range of detection

		if(avg < 90) {
			stopTask(randomWalk);
			stopTask(lineFollow);
			start = 1;
			//stopTask(lineFollow);
			if(avg > 70) {
				speed = 80;
				moveForward(speed, speed);
				wait1Msec(800);
				}else if(avg > 50){
				speed = 75;
				moveForward(speed, speed);
				wait1Msec(800);
				}else if(avg > 30) {
				speed = 60;
				moveForward(speed, speed);
				wait1Msec(800);
				}else if (avg > 20) {
				speed = 55;
				moveForward(speed, speed);
				wait1Msec(800);
				}else if (avg > 13) {
				speed = 30;
				moveForward(speed, speed);
				wait1Msec(400);
				} else if (avg > 7) {
				speed = 15;
				moveForward(speed, speed);
				wait1Msec(300);
				}else if (avg > 3) {
				speed = 5;
				moveForward(speed, speed);
				wait1Msec(100);
				}else {
				//stop for 4 second
				moveForward(0, 0);
				wait1Msec(4000);
				//backward for 1.5 second
				moveBackwards(-40, -40);
				wait1Msec(1500);
				//randomly turn in any direction
				turnRandomly();
				//continute random walk
				start = 0;
				startTask(randomWalk);
				startTask(lineFollow);
			}
		}else {
			if(start == 1) {
				startTask(randomWalk);
				startTask(lineFollow);
				start = 0;
			}
		}
		avg = 0;
		total = 0;
	}
}

task main()
{
	startTask(randomWalk);
	startTask(lineFollow);
	startTask(detect);

	while(true) {

	}
}
